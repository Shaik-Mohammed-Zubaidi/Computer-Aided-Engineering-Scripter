#!/usr/bin/env python3
"""
export_scripts.py
-----------------
Usage:
    python export_scripts.py history.json exported_scripts

• history.json  → file generated by your Flask app
• exported_scripts/ → any folder name; will be created if missing

The script writes N files:
    0001_cube1.py
    0002_cube1_steel.py
    0003_mesh_count.py
…each containing the exact code from the JSON 'output' field, plus a
header comment with the original user input and timestamp.
"""

import json, pathlib, re, sys
from datetime import datetime

def sanitize(text: str, max_len: int = 32) -> str:
    """Return a filesystem-safe slug from user input."""
    slug = re.sub(r"[^A-Za-z0-9]+", "_", text.strip()).strip("_")
    return slug[:max_len] or "script"

def main(json_path: str, out_dir: str):
    src = pathlib.Path(json_path)
    if not src.is_file():
        sys.exit(f"❌  JSON file not found: {src}")

    dst = pathlib.Path(out_dir)
    dst.mkdir(parents=True, exist_ok=True)

    with src.open("r", encoding="utf-8") as fp:
        data = json.load(fp)

    if not isinstance(data, list):
        sys.exit("❌  JSON root must be a list of objects.")

    for idx, entry in enumerate(data, start=1):
        user   = entry.get("input", "")
        code   = entry.get("output", "")

        if not code:
            print(f"⚠️  Skipping item #{idx}: no 'output'.")
            continue

        # filename: 0001_<slug>.py
        slug = sanitize(user)
        fname = f"{idx:04d}_{slug}.py"
        fpath = dst / fname

        header = (
            f'# Auto-exported from history.json\n'
            f'# User input: {user}\n\n'
        )

        with fpath.open("w", encoding="utf-8") as fw:
            fw.write(header + code.rstrip() + "\n")

        print(f"✅  Wrote {fpath}")

    print(f"\nDone. {idx} entries processed → {dst.resolve()}")

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python export_scripts.py <history.json> <output_folder>")
        sys.exit(1)
    main(sys.argv[1], sys.argv[2])
